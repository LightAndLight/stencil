{-# language GADTs #-}
{-# language GeneralizedNewtypeDeriving #-}
{-# language OverloadedStrings #-}
{-# language OverloadedLists #-}
{-# language QuasiQuotes #-}

import Stencil
import Stencil.CmdLine

import Control.Monad
import Data.Functor
import Data.Monoid
import Data.String
import Options.Applicative
import System.Environment
import System.Exit
import System.IO
import Turtle.Prelude hiding (stderr)

import qualified Data.Text as Text

cabalFile =
  [template|
-- Initial ${package-name}.cabal generated by cabal init.  For further documentation, 
-- see http://haskell.org/cabal/users-guide/

name:                ${package-name}
version:             ${version}
-- synopsis:
-- description:
license:             ${license}
license-file:        LICENSE
author:              ${author-name}
maintainer:          ${author-email}
-- copyright:
-- category:
build-type:          Simple
extra-source-files:  ChangeLog.md
cabal-version:       >=1.10

library
  -- exposed-modules:
  -- other-modules:
  -- other-extensions:
  build-depends:       base >=4.9 && <4.10
  -- hs-source-dirs:
  default-language:    Haskell2010
|]

shellNix =
  [template|
{ nixpkgs ? import <nixpkgs> {}, compiler ? "ghc821" }:

let

  inherit (nixpkgs) pkgs;

  haskellPackages = if compiler == "default"
                       then pkgs.haskellPackages
                       else pkgs.haskell.packages.\${compiler};

  drv = import ./default.nix { inherit nixpkgs compiler; };

in

  if pkgs.lib.inNixShell then drv.env else drv
|]

defaultNix =
  [template|
{ nixpkgs ? import <nixpkgs> {}, compiler ? "ghc821" }:

let

  inherit (nixpkgs) pkgs;

  f = import ./${package-name}.nix;

  haskellPackages = if compiler == "default"
                       then pkgs.haskellPackages
                       else pkgs.haskell.packages.\${compiler};

  drv = haskellPackages.callPackage f {};

in

  drv
|]

coolerCabalInit =
  promptRequired "package-name" "Package Name" *>
  promptDefault "version" "Version" "0.1.0.0" *>
  promptChoice
    "license"
    "License"
    [ "GPL-2"
    , "GPL-3"
    , "LGPL-2.1"
    , "LGPL-3"
    , "BSD2"
    , "BSD3"
    , "MIT"
    , "ISC"
    , "MPL-2.0"
    , "Apache-2.0"
    , "PublicDomain"
    , "AllRightsReserved"
    ]
    (Just "BSD3") *>
  promptRequired "author-name" "Author Name" *>
  promptRequired "author-email" "Author Email" *>
  fillTemplate [template|${package-name}.cabal|] cabalFile *>
  fillTemplate [template|default.nix|] defaultNix *>
  fillTemplate [template|shell.nix|] shellNix *>
  templatedScript
    [template|${package-name}.nix|]
    (inproc "cabal2nix" ["."] mempty)
    (\val -> output (fromString $ Text.unpack val))

initInfo :: ParserInfo ()
initInfo =
  info
    ((strArgument
     (metavar "STENCIL" <>
      help "The stencil to run") $> ()) <**>
     helper)
    fullDesc

handleParseResult' :: Maybe String -> ParserResult a -> IO a
handleParseResult' Nothing res = handleParseResult res
handleParseResult' (Just progName) res =
  case res of
    Failure a -> do
      let (msg, exit) = renderFailure a progName
      case exit of
        ExitSuccess -> putStrLn msg
        _ -> hPutStrLn stderr msg
      exitWith exit
    _ -> handleParseResult res

main = do
  args <- getArgs
  case args of
    "init" : "haskell/nix" : rest -> do
      env <-
        handleParseResult' (Just "haskell/nix") $
        execParserPure defaultPrefs (nonInteractive coolerCabalInit) rest
      void $ runStepsCmdLine coolerCabalInit env
    "init" : arg : _ | head arg /= '-' -> error "stencil error: unknown template name"
    "init" : rest ->
      void . handleParseResult $ execParserPure defaultPrefs initInfo rest
    _ ->
      void . handleParseResult $
      execParserPure defaultPrefs
      (info
        (subparser
          (command "init" initInfo)
          <**>
          helper)
        fullDesc)
      args
